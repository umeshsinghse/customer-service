version: 0.2

# AWS CodeBuild buildspec for production deployment
# This file defines the build process for deploying the customer-service to production environment

env:
  variables:
    AWS_DEFAULT_REGION: us-east-1
    AWS_ACCOUNT_ID: "123456789012"  # Replace with your AWS Account ID
    ECR_REPOSITORY: customer-service
    ECS_CLUSTER_NAME: customer-service-production
    ECS_SERVICE_NAME: customer-service-production
    CONTAINER_NAME: customer-service
  parameter-store:
    # Store sensitive values in AWS Systems Manager Parameter Store
    DB_HOST: /customer-service/production/db/host
    DB_PASSWORD: /customer-service/production/db/password
  secrets-manager:
    # Store highly sensitive values in AWS Secrets Manager
    API_SECRET_KEY: customer-service/production:api_secret_key

phases:
  pre_build:
    commands:
      - echo Logging in to Amazon ECR...
      - aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com
      - REPOSITORY_URI=$AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$ECR_REPOSITORY
      - IMAGE_TAG=${CODEBUILD_RESOLVED_SOURCE_VERSION:-latest}
      - echo Repository URI is $REPOSITORY_URI
      - echo Image tag is $IMAGE_TAG
      
      # Production-specific pre-deployment checks
      - echo "Running pre-deployment validation..."
      - |
        # Verify image exists in ECR
        aws ecr describe-images --repository-name $ECR_REPOSITORY --image-ids imageTag=$IMAGE_TAG || {
          echo "Error: Image $IMAGE_TAG not found in ECR repository $ECR_REPOSITORY"
          exit 1
        }
        
      - |
        # Optional: Run security scan
        echo "Running security scan..."
        # aws ecr start-image-scan --repository-name $ECR_REPOSITORY --image-id imageTag=$IMAGE_TAG
        
  build:
    commands:
      - echo Build started on `date`
      - echo Deploying to production with blue-green strategy...
      
      # Blue-Green deployment strategy
      - |
        # Get current task definition
        CURRENT_TASK_DEF=$(aws ecs describe-services --cluster $ECS_CLUSTER_NAME --services $ECS_SERVICE_NAME --query 'services[0].taskDefinition' --output text)
        echo "Current task definition: $CURRENT_TASK_DEF"
        
      - |
        # Create new task definition with updated image
        TASK_DEFINITION=$(aws ecs describe-task-definition --task-definition $ECS_SERVICE_NAME --query 'taskDefinition')
        NEW_TASK_DEFINITION=$(echo $TASK_DEFINITION | jq --arg IMAGE "$REPOSITORY_URI:$IMAGE_TAG" '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.placementConstraints) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')
        NEW_TASK_INFO=$(aws ecs register-task-definition --cli-input-json "$NEW_TASK_DEFINITION")
        NEW_REVISION=$(echo $NEW_TASK_INFO | jq '.taskDefinition.revision')
        NEW_TASK_DEF="$ECS_SERVICE_NAME:$NEW_REVISION"
        echo "New task definition: $NEW_TASK_DEF"
        
      # Gradual deployment with health checks
      - |
        echo "Starting gradual deployment..."
        # Update service with new task definition
        aws ecs update-service \
          --cluster $ECS_CLUSTER_NAME \
          --service $ECS_SERVICE_NAME \
          --task-definition $NEW_TASK_DEF \
          --deployment-configuration "maximumPercent=200,minimumHealthyPercent=50"
          
      - |
        echo "Waiting for deployment to stabilize..."
        aws ecs wait services-stable \
          --cluster $ECS_CLUSTER_NAME \
          --services $ECS_SERVICE_NAME \
          --cli-read-timeout 1200  # 20 minutes timeout
          
      # Health checks and validation
      - |
        echo "Running post-deployment health checks..."
        # Get service endpoint (replace with your actual endpoint)
        # ENDPOINT=$(aws ecs describe-services --cluster $ECS_CLUSTER_NAME --services $ECS_SERVICE_NAME --query 'services[0].loadBalancers[0].targetGroupArn' --output text)
        
        # Run health checks
        for i in {1..5}; do
          echo "Health check attempt $i/5"
          # Replace with your actual health check endpoint
          # if curl -f -s http://your-production-endpoint/health > /dev/null; then
          #   echo "Health check passed"
          #   break
          # else
          #   echo "Health check failed, retrying in 30 seconds..."
          #   sleep 30
          # fi
          
          # For now, just verify service is running
          RUNNING_COUNT=$(aws ecs describe-services --cluster $ECS_CLUSTER_NAME --services $ECS_SERVICE_NAME --query 'services[0].runningCount' --output text)
          DESIRED_COUNT=$(aws ecs describe-services --cluster $ECS_CLUSTER_NAME --services $ECS_SERVICE_NAME --query 'services[0].desiredCount' --output text)
          
          if [ "$RUNNING_COUNT" = "$DESIRED_COUNT" ] && [ "$RUNNING_COUNT" -gt 0 ]; then
            echo "Service health check passed: $RUNNING_COUNT/$DESIRED_COUNT tasks running"
            break
          else
            echo "Service health check failed: $RUNNING_COUNT/$DESIRED_COUNT tasks running"
            if [ $i -eq 5 ]; then
              echo "Health checks failed after 5 attempts, rolling back..."
              # Rollback to previous task definition
              aws ecs update-service \
                --cluster $ECS_CLUSTER_NAME \
                --service $ECS_SERVICE_NAME \
                --task-definition $CURRENT_TASK_DEF
              exit 1
            fi
            sleep 30
          fi
        done
        
  post_build:
    commands:
      - echo Build completed on `date`
      - echo Production deployment completed successfully
      
      # Final verification and logging
      - |
        SERVICE_INFO=$(aws ecs describe-services --cluster $ECS_CLUSTER_NAME --services $ECS_SERVICE_NAME)
        RUNNING_COUNT=$(echo $SERVICE_INFO | jq '.services[0].runningCount')
        DESIRED_COUNT=$(echo $SERVICE_INFO | jq '.services[0].desiredCount')
        TASK_DEFINITION=$(echo $SERVICE_INFO | jq -r '.services[0].taskDefinition')
        
        echo "=== PRODUCTION DEPLOYMENT SUMMARY ==="
        echo "Service: $ECS_SERVICE_NAME"
        echo "Cluster: $ECS_CLUSTER_NAME"
        echo "Task Definition: $TASK_DEFINITION"
        echo "Running Tasks: $RUNNING_COUNT/$DESIRED_COUNT"
        echo "Image: $REPOSITORY_URI:$IMAGE_TAG"
        echo "Deployment Time: $(date)"
        echo "====================================="
        
      # Optional: Send notification
      - |
        echo "Sending deployment notification..."
        # aws sns publish --topic-arn arn:aws:sns:us-east-1:123456789012:production-deployments \
        #   --message "Customer Service successfully deployed to production. Image: $REPOSITORY_URI:$IMAGE_TAG"
        
artifacts:
  files:
    - '**/*'
  name: customer-service-production-deployment
  
cache:
  paths:
    - '/root/.m2/**/*'